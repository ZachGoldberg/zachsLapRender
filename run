#!/bin/bash

export PYTHONPATH=src/:$PYTHONPATH
pushd "$base" &> /dev/null

trap 'popd &> /dev/null' EXIT

SCRIPT=$(basename "$0")
RUNPWD=$(dirname "$0")
COMMAND=${1-help}
FUNCTION=run_$(echo $COMMAND | sed 's/-/_/g')
shift

# ensure the working directory is the directory of this script
cd $(cd $(dirname "$0") && pwd)

# Utility Functions
die() {
	echo "$@" >&2
	exit 1
}
available_functions() {
	declare -F | sed 's/^declare -f //' | grep '^run_'
}

available_commands() {
	available_functions | sed 's/^run_//' | sed 's/_/-/g'
}

remove_pyc_files() {
	find . -name '*.pyc' -delete
}

check_root() {
	[ "$(id -u)" == 0 ]
}

run_python() {
    # Run python with all of our ENV vars
    python $@
}

run_zachs() {
    python src/main.py $@
}

run_test_harrys_csv_parser() {
    run_zachs --analyze --input-data-file=samples/LapTimerGPSRecDB.csv
}

run_install_completion () {
    echo "[ -x $PWD/run ] && eval \"\`$PWD/run completion\`\"" >> ~/.bashrc

}

run_completion() {
	# This needs to be run through `eval` in order to work in your shell
	cat <<-EOF
		_run_completion() {
			COMPREPLY=( \$(COMP_WORDS="\${COMP_WORDS[*]}" COMP_CWORD=\$COMP_CWORD "\$1") )
		}
		complete -o default -F _run_completion $SCRIPT
	EOF
}

run_help() {
	echo "Available commands:"
	available_commands | while read name; do
		echo "	$name"
	done
}

# Bash completion
if [ -n "$COMP_WORDS" ]; then
	COMP_WORDS=( $COMP_WORDS )
	FIRST_WORD=${COMP_WORDS[1]}
	CURRENT_WORD=${COMP_WORDS[COMP_CWORD]}

	case "$COMP_CWORD" in
		1)
			available_commands | grep "^$CURRENT_WORD"
			;;
		3)
	esac

	exit 0
fi

# Check for invalid command
if ! available_functions | grep -q "^$FUNCTION$"; then
	die "'$COMMAND' is not a valid command. Type '$SCRIPT help' for possible commands."
fi

# Execute the command
$FUNCTION "$@"
